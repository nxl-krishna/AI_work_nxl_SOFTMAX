%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% IEEE-Styled Lab Report - Final Polished Version
% This document is self-contained and ready to compile.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[10pt, a4paper, twocolumn]{article}

% --- PACKAGES ---
\usepackage[a4paper, top=1in, bottom=1in, left=0.75in, right=0.75in]{geometry}
\usepackage{amsmath}
\usepackage{times}      % Use Times font for the body text
\usepackage{abstract}   % For a proper abstract environment
\usepackage{hyperref}   % For clickable links (optional)

% --- Custom Command for the Full-Width Heading ---
% This redefines the standard \maketitle command to produce our desired heading
\makeatletter
\renewcommand{\maketitle}{%
  \twocolumn[ % This command creates a full-width block at the top of a twocolumn page
    \begin{center}
      \vspace*{1em} % Add a little space at the top
      \rmfamily\huge % Use Roman (serif) font, Huge size, NOT bold
      LAB ASSIGNMENT 4: JIG-SAW PUZZLE SOLVER
      \vspace{0.5em}
      \hrule
      \vspace{2em} % Space between the heading and the two-column content
    \end{center}
  ]
}
\makeatother


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle % This command now creates our custom full-width heading

% --- The rest of the report flows in two columns ---

% --- ABSTRACT AND KEYWORDS ---
\subsection*{Abstract}
\textit{This report outlines the process of building an intelligent agent to solve a scrambled jigsaw puzzle. The puzzle is treated as a state-space search problem, which we tackle using a Simulated Annealing algorithm. The core of the agent is a cost function that measures how well the pieces of the puzzle fit together. Through our implementation, we discovered that a simple search was not enough; a patient, multi-run strategy and a crucial post-processing step to fix the final orientation were necessary to achieve a perfect solution. The final program successfully and consistently solves the puzzle.}

\vspace{1em}
\noindent\textbf{\textit{Index Terms---State-Space Search, Simulated Annealing, Cost Function, Combinatorial Optimization, Jigsaw Puzzle, Heuristic Search.}}
\vspace{1em}
\hrule
\vspace{1em}


\subsection*{A. Introduction}
Jigsaw puzzles are a classic example of a combinatorial problem. The challenge is that the number of possible ways to arrange the pieces grows incredibly fast. For the $4 \times 4$ puzzle in this assignment, there are over 20 trillion possible arrangements. Trying to check every single one (a brute-force approach) would be impossible.

To solve this, we needed a smarter approach. We chose Simulated Annealing, a search algorithm that's great for these kinds of problems with huge search spaces. It's based on the real-world process of annealing metal: by heating it up and cooling it down very slowly, the metal settles into its strongest, most stable state. Our algorithm does the same, "cooling" a scrambled puzzle into a perfectly solved, low-energy state.

\subsection*{B. Problem Formulation}
To let our AI agent work on the puzzle, we first had to describe the problem in a way it could understand. We broke it down into the components of a state-space search:

\begin{itemize}
    \item \textbf{State:} We defined a "state" as any possible arrangement of the puzzle pieces. In our code, this is a $4 \times 4$ grid where each cell holds a number representing a unique piece.
    
    \item \textbf{Initial State:} This is simply the scrambled puzzle that we start with, loaded from the \texttt{scrambled\_lena.mat} file.
    
    \item \textbf{Successor Function:} This is the "move" our agent can make. We kept it simple: the agent can randomly pick any two pieces on the board and swap their positions. This creates a new, slightly different state.
    
    \item \textbf{Cost Function:} This is the most important part. To guide the search, we needed a way to score how "good" any given arrangement is. Our cost function measures the total visual error between all the pieces that are touching. It does this by calculating the sum of squared differences (SSD) of the pixel values along every internal edge. A perfect fit has a low cost, while a bad fit has a high cost.
    $$ E = \sum_{\text{edges}} \text{SSD}(\text{edge}_1, \text{edge}_2) $$
    
    \item \textbf{Goal State:} The goal is to find the arrangement with the lowest possible cost, which should be the correctly solved image.
\end{itemize}

\subsection*{C. The Simulated Annealing Algorithm}
Our algorithm works like a ball rolling down a bumpy hill, trying to find the lowest point. It starts at a random high point (the scrambled puzzle) and with a high "temperature."

In each step, it tries a random move (a swap). If the move leads "downhill" to a state with a lower cost, it always takes it. However, the real power of the algorithm is that it can sometimes choose to go "uphill" to a state with a higher cost. The probability of making a bad move is given by:
$$ P(\text{accept}) = e^{-\Delta E / T} $$
When the temperature $T$ is high, the algorithm is more likely to take these risky uphill moves, allowing it to escape from small valleys (local minima) and explore the entire landscape. As we slowly lower the temperature, the algorithm becomes more cautious, preferring only to go downhill. Eventually, it "cools" and settles into the deepest valley it has foundâ€”the best solution.

\subsection*{D. Implementation Details}
We built the solver in Python, using NumPy for handling the image grid and Matplotlib to show the results. The development process had a few key challenges and insights:

\begin{enumerate}
    \item \textbf{File Loading:} The provided \texttt{.mat} file was in a text format that standard libraries couldn't read. We had to write a custom file loader from scratch to parse the file's header and pixel data correctly.
    \item \textbf{Parameter Tuning:} We found that the algorithm's "patience" was crucial. A fast cooling schedule often led to imperfect results. We had to fine-tune the parameters to use a very slow cooling rate ($\alpha = 0.99995$) and a large number of iterations (500,000) to give the solver enough time to find the perfect fit.
    \item \textbf{Multiple Runs:} Since the algorithm is random, it doesn't find the best path every time. To make our solver more reliable, we made it run the entire process five times and automatically keep the best solution it found across all attempts.
    \item \textbf{Orientation Correction:} A major breakthrough was realizing that a "perfectly" assembled puzzle (with a cost of zero) could still be wrong if the entire image was rotated or if the rows were "wrapped" (e.g., the bottom row appearing at the top). We built a final, post-processing function that checks all possible rotations and shifts to fix these issues and guarantee a 100\% visually correct result.
\end{enumerate}

\subsection*{E. Results}
The initial scrambled puzzle always started with a very high cost, representing its chaotic state. After running our final, patient, multi-run algorithm, it consistently found a solution with a cost of zero. This means all the pieces were matched perfectly with their correct neighbors. The final orientation-checking step then ensured that this perfectly matched grid was displayed in its true, upright orientation. The final output was a 100\% solved and correct image.

\subsection*{F. Conclusion}
This assignment was a practical demonstration of how a powerful algorithm like Simulated Annealing can be used to solve a very difficult combinatorial problem. The process showed that building a successful agent is not just about implementing the core algorithm, but also about understanding the problem's details. Strategies like patient parameter tuning, multiple runs, and intelligent post-processing were essential to take the solution from "almost correct" to "perfect." The final program is a robust and effective jigsaw puzzle solver.

\end{document}